import{_ as a,r as c,o as i,c as r,a as o,b as e,e as t,d as n}from"./app-4ec55863.js";const s="/images/browser/browser_8.png",h={},l=n('<h1 id="http-的-cookie-机制和缓存控制" tabindex="-1"><a class="header-anchor" href="#http-的-cookie-机制和缓存控制" aria-hidden="true">#</a> HTTP 的 Cookie 机制和缓存控制</h1><h2 id="什么是-cookie" tabindex="-1"><a class="header-anchor" href="#什么是-cookie" aria-hidden="true">#</a> 什么是 Cookie</h2><p>因为 HTTP 是“无状态”的，所以无法支持需要记录状态的操作。如果新闻网站，视频网站或电商网站要对用户进行个性化定制怎么做呢，那么就需要引入外力 Cookie 了。Cookie 像是服务器给浏览器贴上的标签，当服务器看到它，就想起它是谁了。</p><h2 id="cookie-工作流程" tabindex="-1"><a class="header-anchor" href="#cookie-工作流程" aria-hidden="true">#</a> Cookie 工作流程</h2><p>见下图：</p><p><img src="'+s+`" alt="预览图"></p><h2 id="cookie-的属性" tabindex="-1"><a class="header-anchor" href="#cookie-的属性" aria-hidden="true">#</a> Cookie 的属性</h2><p><code>Expires</code>：过期时间，用的是绝对时间点，可以理解为“截止日期”。</p><p><code>Max-Age</code>：用的是相对时间，单位是秒，浏览器用收到报文的时间点再加上 <code>Max-Age</code>，就可以得到失效的绝对时间。</p><p><code>Expires</code> 和 <code>Max-Age</code> 可以同时出现，两者的失效时间可以一致，也可以不一致，但浏览器会优先采用 <code>Max-Age</code> 计算失效期。</p><p><code>Domain</code> 和 <code>Path</code> 指定了 Cookie 所属的域名和路径，浏览器在发送 Cookie 前会从 <code>URI</code> 中提取出 <code>host</code> 和 <code>path</code> 部分，对比 Cookie 的属性。如果不满足条件，就不会在请求头里发送 Cookie。</p><p><code>HttpOnly</code> 会告诉浏览器，此 Cookie 只能通过浏览器 HTTP 协议传输，禁止其他方式访问，浏览器的 JS 引擎就会禁用 <code>document.cookie</code> 等一切相关的 API，脚本攻击也就无从谈起了。</p><p><code>SameSite</code> 可以避免跨站请求伪造（XSRF）。设置<code>SameSite=Strict</code>可以严格限定 Cookie 不能随着跳转链接跨站发送，而<code>SameSite=Lax</code>则略宽松一点，允许 <code>GET/HEAD</code> 等安全方法，但禁止 <code>POST</code> 跨站发送。</p><p><code>Secure</code> 表示这个 Cookie 仅能用 HTTPS 协议加密传输，明文的 HTTP 协议会禁止发送。但是 Cookie 本身是明文的。</p><h2 id="cookie-的应用" tabindex="-1"><a class="header-anchor" href="#cookie-的应用" aria-hidden="true">#</a> Cookie 的应用</h2><ol><li>Cookie 最基本的一个用途就是身份识别，保存用户的登录信息，实现会话事务。</li><li>Cookie 的另一个常见用途是广告跟踪。</li></ol><h2 id="服务器的缓存控制" tabindex="-1"><a class="header-anchor" href="#服务器的缓存控制" aria-hidden="true">#</a> 服务器的缓存控制</h2><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>// 响应头字段
Cache-Control: max-age=30
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>max-age</code>：告诉浏览器可以缓存该文件多少秒。</li><li><code>no-store</code>：不允许缓存，用于某些变化非常频繁的数据，例如秒杀页面。</li><li><code>no-cache</code>：可以缓存，但在使用之前必须要去服务器验证是否过期，是否有最新的版本。</li><li><code>must-revalidate</code>：如果缓存不过期就可以继续使用，但过期了如果还想用就必须去服务器验证。</li></ul><h2 id="客户端的缓存控制" tabindex="-1"><a class="header-anchor" href="#客户端的缓存控制" aria-hidden="true">#</a> 客户端的缓存控制</h2><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>// 请求头字段
Cache-Control: max-age=0
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>max-age=0</code> 这个意味着不会使用本地缓存，而是请求服务器的资源。</p><p>浏览器的 <code>Ctrl+F5</code> 强制刷新，其实是发送了 <code>Cache-Control: no-cache</code> 给服务器。</p><h2 id="条件请求" tabindex="-1"><a class="header-anchor" href="#条件请求" aria-hidden="true">#</a> 条件请求</h2><p>HTTP 协议定义了一系列 <code>If</code> 开头的“条件请求”字段，专门用来检查验证资源是否过期，而且，验证的责任也交给服务器，浏览器只需“坐享其成”。</p><p>常用的有 <code>if-Modified-Since</code> 和 <code>If-None-Match</code> 两个。需要第一次的响应报文预先提供 <code>Last-modified</code> 和 <code>ETag</code> ，然后第二次请求时就可以带上缓存里的原值，验证资源是否是最新的。</p><p><code>Last-modified</code> 指的是最后的修改时间。对应 <code>if-Modified-Since</code>。</p><p><code>ETag</code> 指的是资源的一个唯一标识，可以精确地识别资源的变动情况，让浏览器能够更有效地利用缓存。对应 <code>If-None-Match</code>。</p><h2 id="结语" tabindex="-1"><a class="header-anchor" href="#结语" aria-hidden="true">#</a> 结语</h2>`,29),p={href:"https://time.geekbang.org/column/intro/100029001?tab=catalog",target:"_blank",rel:"noopener noreferrer"};function k(m,u){const d=c("ExternalLinkIcon");return i(),r("div",null,[l,o("p",null,[e("本文到这里就结束了。这是学习"),o("a",p,[e("《透视HTTP协议》"),t(d)]),e("罗剑锋老师课程的笔记。希望可以帮到你。")])])}const _=a(h,[["render",k],["__file","HTTP的Cookie机制和缓存控制.html.vue"]]);export{_ as default};
