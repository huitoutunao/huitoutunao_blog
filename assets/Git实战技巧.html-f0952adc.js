import{_ as i,r as t,o as c,c as o,a as e,b as a,e as n,d}from"./app-8d691574.js";const r="/images/essays/git_1.jpg",l="/images/essays/git_2.png",p="/images/essays/git_3.png",m="/images/essays/git_4.png",g="/images/essays/git_5.png",h="/images/essays/git_6.png",u="/images/essays/git_7.png",v="/images/essays/git_8.png",b={},k=d('<h1 id="git-实战技巧" tabindex="-1"><a class="header-anchor" href="#git-实战技巧" aria-hidden="true">#</a> Git 实战技巧</h1><p>在日常开发中，Git 对我们的代码管理起到重要作用。因此作为开发人员都要掌握使用它的技巧。</p><h2 id="git-的工作区域和流程" tabindex="-1"><a class="header-anchor" href="#git-的工作区域和流程" aria-hidden="true">#</a> Git 的工作区域和流程</h2><p>见下图：</p><p><img src="'+r+`" alt="git1"></p><p>workspace：工作区，就是平时进行开发改动的地方，是当前看到最新的内容，在开发的过程也就是对工作区的操作。</p><p>Index：暂存区，当执行 <code>git add</code> 的命令后，工作区的文件就会被移入暂存区，暂存区标记了当前工作区中那些内容是被 Git 管理的，当完成某个需求或者功能后需要提交代码，第一步就是通过 <code>git add</code> 先提交到暂存区。</p><p>Repository：本地仓库，位于自己的电脑上，通过 <code>git commit</code> 提交暂存区的内容，会进入本地仓库。</p><p>Remote：远程仓库，用来托管代码的服务器，远程仓库的内容能够被分布在多个地点的处于协作关系的本地仓库修改，本地仓库修改完代码后通过 <code>git push</code> 命令同步代码到远程仓库。</p><p>Git 的常规操作：</p><ol><li>在工作区开发，修改和添加文件；</li><li>将修改后的文件放入暂存区；</li><li>将暂存区的文件提交到本地仓库；</li><li>将本地仓库的修改推送到远程仓库；</li></ol><h2 id="git-基本技巧" tabindex="-1"><a class="header-anchor" href="#git-基本技巧" aria-hidden="true">#</a> Git 基本技巧</h2><ol><li><code>git add</code> 将文件放入暂存区</li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 添加当前所有修改文件至暂存区</span>
$ <span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li><code>git commit</code> 将暂存区的更改文件提交至本地仓库</li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 等价于 git add . 和 git commit -m。注意：对新文件不受影响</span>
$ <span class="token function">git</span> commit <span class="token parameter variable">-am</span> <span class="token string">&#39;提交至本地仓库&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li><code>git pull</code> 将远程仓库代码拉取合并到本地仓库，等同于 <code>git fetch + git merge</code></li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 等同于 git fetch + git rebase(变基)</span>
$ <span class="token function">git</span> pull <span class="token parameter variable">--rebase</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ol start="4"><li><code>git fetch</code> 与 <code>git pull</code> 不同的是 <code>git fetch</code> 操作仅仅只会拉取远程的更改，不会自动进行 <code>merge</code> 操作。对你当前的代码没有影响</li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 拉取特定分支</span>
$ <span class="token function">git</span> fetch <span class="token operator">&lt;</span>远程主机名<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>分支名<span class="token operator">&gt;</span>

<span class="token comment"># 拉取远程主机所有分支</span>
$ <span class="token function">git</span> fetch <span class="token parameter variable">--all</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="5"><li><code>git branch</code> 分支</li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 新建本地分支，但不切换</span>
<span class="token function">git</span> branch <span class="token operator">&lt;</span>branch-name<span class="token operator">&gt;</span>

<span class="token comment"># 查看本地分支</span>
<span class="token function">git</span> branch

<span class="token comment"># 查看远程分支</span>
<span class="token function">git</span> branch <span class="token parameter variable">-r</span>

<span class="token comment"># 查看本地和远程分支</span>
<span class="token function">git</span> branch <span class="token parameter variable">-a</span>

<span class="token comment"># 删除本地分支</span>
<span class="token function">git</span> branch <span class="token parameter variable">-D</span> <span class="token operator">&lt;</span>branch-nane<span class="token operator">&gt;</span>

<span class="token comment"># 重新命名分支</span>
<span class="token function">git</span> branch <span class="token parameter variable">-m</span> <span class="token operator">&lt;</span>old-branch-name<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>new-branch-name<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="git-工作使用" tabindex="-1"><a class="header-anchor" href="#git-工作使用" aria-hidden="true">#</a> Git 工作使用</h2><h3 id="git-rebase" tabindex="-1"><a class="header-anchor" href="#git-rebase" aria-hidden="true">#</a> git rebase</h3><p>rebase 译作为变基，作用和 merge 类似，用于把分支修改合并到当前分支上。</p><p>举个例子：</p><p>现在有 2 个分支，分别是 master 和 test 分支，它们都是基于 test1 提交检出的分支。在 master 分支上分别提交两个文件 <code>3.js</code> 和 <code>4.js</code>，test 分支上分别提交两个文件 <code>1.js</code> 和 <code>2.js</code>。它们的提交记录截图如下：</p><p><img src="`+l+'" alt="git2"></p><p>在 test 分支上执行 <code>git rebase master</code> 命令，可以看到先是逐个应用了 master 分支的更改，然后以 master 分支最后的提交作为基点，再逐个应用 test 的每个更改。最后切换到 master 分支上，执行合并后得到下面记录截图：</p><p><img src="'+p+'" alt="git3"></p><p>上面的例子还是比较简单的，如果在变基时遇到代码冲突，我们需要依次使用 <code>git add</code>、<code>git rebase --continue</code> 的方式来处理冲突，完成 rebase 的过程，如果不想要某次 rebase 的结果，那么需要使用 <code>git rebase --skip</code> 来跳过这次 rebase 操作。</p><p>解决冲突后，运行 <code>git rebase --continue</code> 会出现下面的 <code>vim</code> 界面：</p><p><img src="'+m+'" alt="git4"></p><p>然后键入 <code>:E</code> 进入编辑模式，如果需要修改提交文案，可以键入 <code>i</code>，<code>delete</code> 是删除文案键，更新文案完成后，键入 <code>esc</code> 退出编辑模式，最后键入 <code>:wq</code> 保存并退出。</p><p><code>git merge</code> 在不是 <code>fast-forward</code>（快速合并）的情况下，会产生一条额外的合并记录，类似 <code>Merge branch &#39;xxx&#39; into &#39;xxx&#39;</code> 的一条提交信息。另外，在解决冲突的时候，用 merge 只需要解决一次冲突即可，简单粗暴，而用 rebase 的时候 ，需要依次解决每次的冲突，才可以提交。</p><h3 id="git-rebase-i" tabindex="-1"><a class="header-anchor" href="#git-rebase-i" aria-hidden="true">#</a> <code>git rebase -i</code></h3><p>在开发中，如果遇到多个无效提交想将它们压缩成一次提交，需要使用命令 <code>git rebase -i &lt;base-commit&gt;</code>，其中 <code>&lt;base-commit&gt;</code> 是提交的 hash 值，以它作为起点，把后面的提交压缩（不包含起点），然后会进入 vim 的交互式界面：</p><p><img src="'+g+'" alt="git5"></p><p>我们要使用 Squash 策略进行合并，但至少保留一个 pick，否则命令会执行失败。</p><p><img src="'+h+'" alt="git6"></p><p>退出编辑模式，然后键入 <code>:wq</code> 保存并推出，此时又会出现另一个界面。</p><p><img src="'+u+'" alt="git7"></p><p>键入 <code>:E</code> 进入编辑模式，将更改合并提交的文案，最后再 <code>:wq</code> 保存并退出。</p><div class="custom-container warning"><p class="custom-container-title">注意</p><p>特别注意，只能在自己使用的 test 分支上进行 rebase 操作，不允许在集成分支上进行 rebase，因为这种操作会修改集成分支的历史记录。</p></div><h3 id="git-cherry-pick-获取指定的-commit" tabindex="-1"><a class="header-anchor" href="#git-cherry-pick-获取指定的-commit" aria-hidden="true">#</a> <code>git cherry-pick</code> 获取指定的 commit</h3><p>例如 master 分支上只要 test 分支上新增功能的提交，那么就可以使用 <code>git cherry-pick [commit-hash]</code></p><p>如果合并发生冲突，解决冲突后执行 <code>git add .</code>，然后执行 <code>git cherry-pick --continue</code>。</p><p>如果需要多个 <code>cherry-pick</code> 需要同步到目标分支，可以简写为 <code>git cherry-pick &lt;first-commit-id&gt;...&lt;last-commit-id&gt;</code>，这是一个左开右闭的区间，也就时说 <code>first-commit-id</code> 提交带来的代码的改动不会被合并过去，如果需要合并过去，可以使用 <code>git cherry-pick &lt;first-commit-id&gt;^...&lt;last-commit-id&gt;</code>，它表示包含 <code>first-commit-id</code> 到 <code>last-commit-id</code> 在内的提交都会被合并过去。</p><h3 id="git-revert-回滚某次的提交" tabindex="-1"><a class="header-anchor" href="#git-revert-回滚某次的提交" aria-hidden="true">#</a> git revert 回滚某次的提交</h3><p>git revert 撤销某次操作，此操作不会修改原本的提交记录，而是会新增一条提交记录来抵消某次操作。</p><ul><li><code>git revert &lt;commit-id&gt;</code> 针对普通 commit</li><li><code>git revert &lt;commit-id&gt; -m</code> 针对 merge 的 commit</li></ul><p>git revert 会自动生成一条提交记录。</p><p><img src="'+v+`" alt="git8"></p><p>git reset 会直接将提交记录退回到指定的 commit 上，如果是在自己开发分支上，可以使用这种方式撤销提交记录，之后使用 <code>git push --force</code> 进行推送到远程。多人协作的集成分支上推荐使用 git revert 命令进行撤消提交。这样，提交的历史记录不会被抹去，可以安全的进行撤回。</p><h3 id="不同的工作区域撤销更改" tabindex="-1"><a class="header-anchor" href="#不同的工作区域撤销更改" aria-hidden="true">#</a> 不同的工作区域撤销更改</h3><p>如果提交了 <code>1.js</code> 的文件修改，想将它恢复，那就使用 <code>git checkout -- &lt;filename&gt;</code>，filename 这里是 <code>1.js</code>。</p><h3 id="git-stash-来暂存文件" tabindex="-1"><a class="header-anchor" href="#git-stash-来暂存文件" aria-hidden="true">#</a> git stash 来暂存文件</h3><p>现在你正在用你的 feature 分支上开发新功能。这时，生产环境上出现了一个 bug 需要紧急修复，但是你这部分代码还没开发完，不想提交，怎么办？这个时候可以用 <code>git stash</code> 命令先把工作区已经修改的文件暂存起来，然后切换到 hotfix 分支上进行 bug 的修复，修复完成后，切换回 feature 分支，从堆栈中恢复刚刚保存的内容。</p><p>基础命令如下：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 把本地的改动暂存起来</span>
$ <span class="token function">git</span> stash

<span class="token comment"># 执行存储时，添加备注，方便查找</span>
$ <span class="token function">git</span> stash save <span class="token string">&quot;message&quot;</span>

<span class="token comment"># 查看 stash 列表</span>
$ <span class="token function">git</span> stash list

<span class="token comment"># 应用最近一次暂存的修改，并删除暂存的记录</span>
$ <span class="token function">git</span> stash pop

<span class="token comment"># 应用某个存储,但不会把存储从存储列表中删除，默认使用第一个存储,即 stash@{0}，如果要使用其他个</span>
$ <span class="token function">git</span> stash apply

<span class="token comment"># 应用某个储藏 stash@{$num}</span>
<span class="token function">git</span> stash apply stash@<span class="token punctuation">{</span><span class="token variable">$num</span><span class="token punctuation">}</span>

<span class="token comment"># 删除所有缓存的 stash</span>
$ <span class="token function">git</span> stash <span class="token function">clear</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="git-提交规范类型" tabindex="-1"><a class="header-anchor" href="#git-提交规范类型" aria-hidden="true">#</a> git 提交规范类型</h2><ul><li>feat - 新功能</li><li>fix - 修复 bug</li><li>docs - 文档修改或注释</li><li>style - 代码格式(不影响代码运行)</li><li>refactor - 重构、优化(既不增加新功能，也不是修复 bug)</li><li>perf - 性能优化</li><li>test - 添加测试</li><li>chore - 构建过程或辅助工具的变动</li><li>revert - 回退版本</li></ul><h2 id="结语" tabindex="-1"><a class="header-anchor" href="#结语" aria-hidden="true">#</a> 结语</h2><p>工作中使用 git 比较频繁，除了 <code>git add</code>、<code>git commit</code>、<code>git merge</code>、<code>git pull</code> 和 <code>git push</code> 基础命令之外。今天还扩展了些比较灵活的命令，希望能在日后工作中解决代码管理问题。</p><h2 id="参考文献" tabindex="-1"><a class="header-anchor" href="#参考文献" aria-hidden="true">#</a> 参考文献</h2>`,65),f={href:"https://www.git-scm.com/docs",target:"_blank",rel:"noopener noreferrer"},_={href:"https://juejin.cn/post/6974184935804534815",target:"_blank",rel:"noopener noreferrer"};function x(y,$){const s=t("ExternalLinkIcon");return c(),o("div",null,[k,e("ul",null,[e("li",null,[e("a",f,[a("git 官方文档"),n(s)])]),e("li",null,[e("a",_,[a("我在工作中是如何使用 git 的"),n(s)])])])])}const j=i(b,[["render",x],["__file","Git实战技巧.html.vue"]]);export{j as default};
