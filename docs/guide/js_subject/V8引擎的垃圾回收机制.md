# V8 引擎的垃圾回收机制

## 前言

前端开发工程师应该都有听说过 V8 引擎，它是一种 JavaScript 引擎的实现，所以也可称它为 V8 JavaScript 引擎。

那什么是 JavaScript 引擎呢？我这里贴出[维基百科](https://zh.wikipedia.org/wiki/JavaScript%E5%BC%95%E6%93%8E)的解释：
> JavaScript 引擎是一个专门处理 JavaScript 脚本的虚拟机，一般会附带在网页浏览器之中。

在日常开发中，虽然我们遇到内存溢出而导致程序崩溃的情况比较少，有部分功劳是 V8 引擎自动帮我们管理了内存，可以让我们更加专注的开发业务，但是代码编写的不够严谨也是很容易引起内存泄露，而了解 V8 引擎垃圾回收背后的机制，至少可以增强我们在开发过程中对减少内存占用，避免内存泄漏的主观意识，因此我们今天来聊聊 V8 引擎垃圾回收机制。

## 为什么需要垃圾回收

1. 预防内存泄露导致程序性能下降。
2. V8 引擎的内存限制。（64位系统约 1.4GB，32位系统约 0.7GB）

其中第二点内存被限制的原因是：
1. 起初是给浏览器设计的，JavaScript 作为浏览器的脚本语言，它的主要用途是与用户交互以及操作 DOM，那么这也决定了其作为单线程的本质，单线程意味着执行的代码必须按顺序执行，在同一时间只能处理一个任务，所以不太可能出现使用大量内存的场景。
2. 垃圾回收本身可以看作一种同步任务，它的执行是会阻碍用户的操作体验，如果内存使用过高，那么必然会导致垃圾回收的过程缓慢，浏览器也就越长时间得不到响应。

## 垃圾回收策略

V8 引擎的垃圾回收策略主要是基于分代式垃圾回收机制，其根据对象的存活时间将内存的垃圾回收进行不同的分代，然后对不同的分代采用不同的垃圾回收算法。

### V8 堆的构成

- 新生区：大多数对象被分配在这里。新生区是一个很小的区域，垃圾回收在这个区域非常频繁，与其他区域相独立。
- 老生指针区：这里包含大多数可能存在指向其他对象的指针的对象。大多数在新生区存活一段时间之后的对象都会被挪到这里。
- 老生数据区：这里存放只包含原始数据的对象（这些对象没有指向其他对象的指针）。字符串、封箱的数字以及未封箱的双精度数字数组，在新生区存活一段时间后会被移动到这里。
- 大对象区：这里存放体积超越其他区大小的对象。每个对象有自己 mmap 产生的内存。垃圾回收器从不移动大对象。
- 代码区：代码对象，也就是包含JIT之后指令的对象，会被分配到这里。这是唯一拥有执行权限的内存区（不过如果代码对象因过大而放在大对象区，则该大对象所对应的内存也是可执行的。译注：但是大对象内存区本身不是可执行的内存区）。
- Cell 区、属性 Cell 区、Map 区：这些区域存放 Cell、属性 Cell 和 Map，每个区域因为都是存放相同大小的元素，因此内存结构很简单。

每个区域都由一组内存页构成。内存页是一块连续的内存，经 mmap（或者 Windows 的什么等价物）由操作系统分配而来。除大对象区的内存页较大之外，每个区的内存页都是 1MB 大小，且按 1MB 内存对齐。除了存储对象，内存页还含有一个页头（包含一些元数据和标识信息）以及一个位图区（用以标记哪些对象是活跃的）。另外，每个内存页还有一个单独分配在另外内存区的槽缓冲区，里面放着一组对象，这些对象可能指向其他存储在该页的对象。这就是一套经典配置方案，其他的方案我们稍后讨论。

## 参考文献

[一文搞懂V8引擎的垃圾回收](https://juejin.cn/post/6844904016325902344)
[重点参考1-中文](http://newhtml.net/v8-garbage-collection/)
[重点参考1-英文](http://www.jayconrod.com/posts/55/a-tour-of-v8-garbage-collection)
[参考2](https://segmentfault.com/a/1190000025129635)
[参考3](https://segmentfault.com/a/1190000000440270)