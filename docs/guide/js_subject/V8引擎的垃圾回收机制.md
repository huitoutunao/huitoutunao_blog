# V8 引擎的垃圾回收机制

## 前言

前端开发工程师应该都有听说过 V8 引擎，它是一种 JavaScript 引擎的实现，所以也可称它为 V8 JavaScript 引擎。

那什么是 JavaScript 引擎呢？我这里贴出[维基百科](https://zh.wikipedia.org/wiki/JavaScript%E5%BC%95%E6%93%8E)的解释：
> JavaScript 引擎是一个专门处理 JavaScript 脚本的虚拟机，一般会附带在网页浏览器之中。

在日常开发中，虽然我们遇到内存溢出而导致程序崩溃的情况比较少，有部分功劳是 V8 引擎自动帮我们管理了内存，可以让我们更加专注的开发业务，但是代码编写的不够严谨也是很容易引起内存泄露，而了解 V8 引擎垃圾回收背后的机制，至少可以增强我们在开发过程中对减少内存占用，避免内存泄漏的主观意识，因此我们今天来聊聊 V8 引擎垃圾回收机制。

## 为什么需要垃圾回收

1. 预防内存泄露导致程序性能下降。
2. V8 引擎的内存限制。（64位系统约 1.4GB，32位系统约 0.7GB）

其中第二点内存被限制的原因是：
1. 起初是给浏览器设计的，JavaScript 作为浏览器的脚本语言，它的主要用途是与用户交互以及操作 DOM，那么这也决定了其作为单线程的本质，单线程意味着执行的代码必须按顺序执行，在同一时间只能处理一个任务，所以不太可能出现使用大量内存的场景。
2. 垃圾回收本身可以看作一种同步任务，它的执行是会阻碍用户的操作体验，如果内存使用过高，那么必然会导致垃圾回收的过程缓慢，浏览器也就越长时间得不到响应。

## 垃圾回收策略

V8 引擎的垃圾回收策略主要是基于分代式垃圾回收机制，其根据对象的存活时间将内存的垃圾回收进行不同的分代，然后对不同的分代采用不同的垃圾回收算法。

### V8 堆的构成

- 新生区：大多数对象被分配在这里。新生区是一个很小的区域，垃圾回收在这个区域非常频繁，与其他区域相独立。
- 老生指针区：这里包含大多数可能存在指向其他对象的指针的对象。大多数在新生区存活一段时间之后的对象都会被挪到这里。
- 老生数据区：这里存放只包含原始数据的对象（这些对象没有指向其他对象的指针）。字符串、封箱的数字以及未封箱的双精度数字数组，在新生区存活一段时间后会被移动到这里。
- 大对象区：这里存放体积超越其他区大小的对象。每个对象有自己 [mmap](https://www.cnblogs.com/huxiao-tee/p/4660352.html) 产生的内存。垃圾回收器从不移动大对象。
- 代码区：代码对象，也就是包含 JIT（Just-in-time） 之后指令的对象，会被分配到这里。这是唯一拥有执行权限的内存区（不过如果代码对象因过大而放在大对象区，则该大对象所对应的内存也是可执行的。译注：但是大对象内存区本身不是可执行的内存区）。
- Cell 区、属性 Cell 区、Map 区：这些区域存放 Cell、属性 Cell 和 Map，每个区域因为都是存放相同大小的元素，因此内存结构很简单。

每个区域都由一组内存页构成。内存页是一块连续的内存，经 mmap（或者 Windows 的什么等价物）由操作系统分配而来。除大对象区的内存页较大之外，每个区的内存页都是 1MB 大小，且按 1MB 内存对齐。除了存储对象，内存页还含有一个页头（包含一些元数据和标识信息）以及一个位图区（用以标记哪些对象是活跃的）。另外，每个内存页还有一个单独分配在另外内存区的槽缓冲区，里面放着一组对象，这些对象可能指向其他存储在该页的对象。这就是一套经典配置方案，其他的方案我们稍后讨论。

### 识别指针

垃圾回收器面临的第一个问题是，如何才能在堆中区分指针和数据，因为指针指向着活跃的对象。大多数垃圾回收算法会将对象在内存中挪动（以便减少内存碎片，使内存紧凑），因此即使不区分指针和数据，我们也常常需要对指针进行改写。

目前主要有三种方法来识别指针：

- 保守法：这种方法对于缺少编译器支持的情况非常必要。大体上，我们将所有堆上对齐的字都认为是指针，这就意味着有些数据也会被误认为是指针。于是某些实际是数字的假指针，会被误认为指向活跃的对象，则我们会时常出现一些奇异的内存泄漏。（译注：因为垃圾回收器会以为死对象仍然还有指针指向，错将死对象误认为活跃对象）而且我们也不能移动任何内存区域，因为这很可能会导致数据遭到破坏。这样，我们便无法通过紧凑内存来获得任何好处（比如更容易的内存分配、更少的内存访问、更有效的内存局部性缓存）。C/C++ 的垃圾回收器扩展会采用这种方式，比如 Boehm-Demers-Weiser。
译注：如果内存是紧凑的，则内存分配时可以更容易分配较大片的内存，而无需因内存碎片而不断查找；同时，由于已分配的内存是连续或近似连续的，而Cahce所能缓存的内存有限，如果内存被Cache缓存起来，无需频繁地迫使Cache更换缓存的内存。C/C++ 由于指针算术的存在，编译器无法确定哪些内存是真正的垃圾，因而无法给垃圾回收器有效的提示，进而导致垃圾回收器不得不采取这样的保守策略。
- 编译器提示法：如果我们和静态语言打交道，则编译器能够准确地告诉我们每个类当中指针的具体位置。而一旦我们知道对象是哪个类实例化得到的，我们就能知道对象中所有的指针。JVM 选择了这样的方法来进行垃圾回收。可惜，这种方法对于 JS 这样的动态语言来说不太好使，因为JS中对象的任何属性既可能是指针，也可能是数据。
- 标记指针法：这种方法需要在每个字的末位预留一位来标记这个字代表的是指针抑或数据。这种方法需要一定的编译器支持，但实现简单，而且性能不俗。V8 采用的就是这种方法。某些静态语言也采用了这样的方法，如 OCaml。

V8 将所有属于 -2^30…2^30-1 范围内的小整数（V8 内部称其为 Smis）以 32bit 字宽来存储，其中的最低一位保持为 0，而指针的最低两位则为 01。由于对象以 4 字节对齐，因此这样表达指针没有任何问题。大多数对象所含有的只是一组标记后的字，因此垃圾回收可以进行的很快。而有些类型的对象，比如字符串，我们确定它只含有数据，因此无需标记。

## 分代回收

脚本中，绝大多数对象的生存期很短，只有某些对象的生存期较长。为利用这一特点，V8 将堆进行了分代。对象起初会被分配在新生区（通常很小，只有 1-8 MB，具体根据行为来进行启发）。在新生区的内存分配非常容易：我们只需保有一个指向内存区的指针，不断根据新对象的大小对其进行递增即可。当该指针达到了新生区的末尾，就会有一次清理（小周期），清理掉新生区中不活跃的死对象。对于活跃超过 2 个小周期的对象，则需将其移动至老生区。老生区在标记－清除或标记－紧缩（大周期）的过程中进行回收。大周期进行的并不频繁。一次大周期通常是在移动足够多的对象至老生区后才会发生。至于足够多到底是多少，则根据老生区自身的大小和程序的动向来定。

由于清理发生的很频繁，清理必须进行的非常快速。V8 中的清理过程称为 Scavenge 算法，是按照 [Cheney](https://en.wikipedia.org/wiki/Cheney's_algorithm) 的算法实现的。这个算法大致是，新生区被划分为两个等大的子区：出区、入区。绝大多数内存的分配都会在出区发生（但某些特定类型的对象，如可执行的代码对象是分配在老生区的），当出区耗尽时，我们交换出区和入区（这样所有的对象都归属在入区当中），然后将入区中活跃的对象复制至出区或老生区当中。在这时我们会对活跃对象进行紧缩，以便提升 Cache 的内存局部性，保持内存分配的简洁快速。

在这个算法的执行过程中，我们始终维护两个出区中的指针：allocationPtr 指向我们即将为新对象分配内存的地方，scanPtr 指向我们即将进行活跃检查的下一个对象。scanPtr 所指向地址之前的对象是处理过的对象，它们及其邻接都在出区，其指针都是更新过的，位于 scanPtr 和 allocationPtr 之间的对象，会被复制至出区，但这些对象内部所包含的指针如果指向入区中的对象，则这些入区中的对象不会被复制。逻辑上，你可以将 scanPtr 和 allocationPtr 之间的对象想象为一个广度优先搜索用到的对象队列。

译注：广度优先搜索中，通常会将节点从队列头部取出并展开，将展开得到的子节点存入队列末端，周而复始进行。这一过程与更新两个指针间对象的过程相似。

我们在算法的初始时，复制新区所有可从根对象达到的对象，之后进入一个大的循环。在循环的每一轮，我们都会从队列中删除一个对象，也就是对 scanPtr 增量，然后跟踪访问对象内部的指针。如果指针并不指向入区，则不管它，因为它必然指向老生区，而这就不是我们的目标了。而如果指针指向入区中某个对象，但我们还没有复制（未设置转发地址），则将这个对象复制至出区，即增加到我们队列的末端，同时也就是对 allocationPtr 增量。这时我们还会将一个转发地址存至出区对象的首字，替换掉 Map 指针。这个转发地址就是对象复制后所存放的地址。垃圾回收器可以轻易将转发地址与 Map 指针分清，因为 Map 指针经过了标记，而这个地址则未标记。如果我们发现一个指针，而其指向的对象已经复制过了（设置过转发地址），我们就把这个指针更新为转发地址，然后打上标记。

算法在所有对象都处理完毕时终止（即 scanPtr 和 allocationPtr 相遇）。这时入区的内容都可视为垃圾，可能会在未来释放或重用。

## 结语

以上内容整理自这篇文章，有兴趣的可以去读[原文](http://www.jayconrod.com/posts/55/a-tour-of-v8-garbage-collection)。

## 参考文献

- [A tour of V8: Garbage Collection(EN)](http://www.jayconrod.com/posts/55/a-tour-of-v8-garbage-collection)
- [A tour of V8: Garbage Collection(CN)](http://newhtml.net/v8-garbage-collection/)
- [一文搞懂V8引擎的垃圾回收](https://juejin.cn/post/6844904016325902344)
- [深入理解 Chrome V8 垃圾回收机制](https://segmentfault.com/a/1190000025129635)
- [浅谈 V8 引擎中的垃圾回收机制](https://segmentfault.com/a/1190000000440270)