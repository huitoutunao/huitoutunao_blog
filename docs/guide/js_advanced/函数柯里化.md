# 函数柯里化

## 柯里化是什么

在计算机科学中，柯里化（Currying），又译为卡瑞化或加里化，是把接受多个参数的函数变换成接受一个单一参数的函数。柯里化不会调用函数，它只是对函数进行转换。

函数柯里化的基本方法和函数绑定 [bind()](/guide/js_subject/模拟实现call、apply和bind.html#bind) 一样（唯一不同是 `bind` 强制绑定了 `context`）：使用一个闭包返回一个函数。两者的区别在于，当函数被调用时，返回的函数还需要设置一些传入的参数。例如：一个函数从可调用的 `fn(a, b, c)` 转换成可调用的 `fn(a)(b)(c)`。

## 柯里化的实现

首先看个简单的例子：
```js
function curry (fn) {
    return function (a) {
        return function (b) {
            return fn(a, b)
        }
    }
}

function sum (a, b) {
    return a + b
}

var sumCurry = curry(sum)
console.log(sumCurry(2)(3)) // 5
```

分析：`curry(sum)` 执行结果是 `function (a)`，当它被 `sumCurry(2)` 这样调用时，它的参数会被保存在词法作用域中（[闭包](/guide/js_advanced/作用域和闭包)），然后返回一个 `function (b)`，接着这个函数被 `sumCurry(3)` 调用，并且，它将该调用传递给原始的 `sum` 函数。

其实上面的 `curry()` 可以优化成如下：
```js
function curry (fn) {
    var args = [].slice.call(arguments, 1)
    return function () {
        var newArgs = args.concat([].slice.call(arguments))
        return fn.apply(this, newArgs)
    }
}
```

如果 `sum(a, b, c)` 携带 3 个参数呢？`curry()` 函数还要再返回 `function (c)`。如果 `sum` 携带 4、5 个参数呢？显然上面那种写法会严重影响阅读体验。为了解决这个问题，请看下面代码：
```js
// help_curry() 是上面 curry() 优化后作为协助的函数
function help_curry (fn) {
    var args = [].slice.call(arguments, 1)
    // debugger;
    return function () {
        var newArgs = args.concat([].slice.call(arguments))
        // debugger;
        return fn.apply(this, newArgs)
    }
}

function curry (fn, len) {
    len = len || fn.length
    // debugger;
    return function () {
        if (arguments.length < len) {
            var unite = [fn].concat([].slice.call(arguments))
            // debugger;
            return curry(help_curry.apply(this, unite), len - arguments.length)
        } else {
            // debugger;
            return fn.apply(this, arguments)
        }
    }
}

var fn = curry(function (a, b, c) {
    return [a, b, c]
})

console.log(fn('a', 'b')('c')) // ["a", "b", "c"]
```

为了更好的理解上面逻辑，建议把我注释的 `debugger` 放开，在浏览器的调试面板查看。文中涉及到的 `call` 和 `apply` 方法，如果不了解的，可以[戳这里学习](/guide/js_subject/模拟实现call、apply和bind)。

## 柯里化的应用

现在我们已经了解了柯里化的定义以及如何实现，那它到底有什么用呢？
