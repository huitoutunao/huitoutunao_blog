# 继承

## 原型链继承
```js
function Parent () {
    this.name = 'Jack'
}
Parent.prototype.getName = function () {
    return this.name
}

function Child () {
    this.age = 20
}
Child.prototype = new Parent()
Child.prototype.getAge = function () {
    return this.age
}

var person = new Child()
console.log(person.getName()) // Jack
```

分析：我们看这句代码 `Child.prototype = new Parent()`，Child 的原型被换成了 Parent 的实例，目前 Child 的新原型不仅具有作为一个 Parent 的实例所拥有的全部属性和方法，而且内部还有一个指针，指向了 Parent 的原型。  
调用 `person.getName()` 这个会经历三个步骤：1、搜索实例；2、搜索 Child.prototype；3、搜索 Parent.prototype，最后一步才找到结果。通过实现原型链，Child 的实例成功在 Parent 定义中找到了需要的方法。

问题：1、引用类型值的原型属性会被所有实例共享；2、在创建子类型的实例时，不能向父类的构造函数中传递参数；

第一个问题举例如下：
```js
function Parent () {
    this.fruit = ['apple', 'pear']
}
function Child () {}
Child.prototype = new Parent()

var one = new Child()
one.fruit.push('banner')
console.log(one.fruit) // apple, pear, banner

var two = new Child()
console.log(two.fruit) // apple, pear, banner
```
因此实践中很少单独使用原型链。

## 借用构造函数

## 组合继承

## 原型式继承

## 寄生式继承

## 寄生组合式继承